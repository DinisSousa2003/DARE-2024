import json
import secrets
import unittest
from hashlib import sha256
from nacl.signing import SigningKey, VerifyKey

#Constants
PERMITTED_OPERATORS = {'create', 'add', 'remove', 'message'}

def hex_hash(byte_str):
    """Returns the SHA-256 hash of byte string ``byte_str``, encoded as hexadecimal."""
    return sha256(byte_str).hexdigest()

def sign_msg(signing_key, message):
    """
    Takes a message ``message`` (given as a dictionary), JSON-encodes it, and signs it using
    ``signing_key``. Returns a byte string in which the first 32 bytes are the public key, the next
    64 bytes are the signature, and the rest is the JSON-encoded message.
    """
    public_key = signing_key.verify_key.encode()
    signed_msg = signing_key.sign(json.dumps(message).encode('utf-8'))
    return public_key + signed_msg

def verify_msg(signed_msg):
    """
    Takes a byte string of the form generated by ``sign_msg()``, checks the validity of the
    signature, and parses the JSON into a dictionary. The public key that signed the message is
    added to the dictionary under the key ``signed_by`` (as a hexadecimal string). Raises an
    exception if the signature is not valid.
    """
    public_key = VerifyKey(signed_msg[0:32]) # first 32 bytes are pubkey
    verified = json.loads(public_key.verify(signed_msg[32:]))
    return {**verified, 'signed_by': signed_msg[0:32].hex()}

def create_op(signing_key):
    """Returns a group creation operation signed by ``signing_key``."""
    return sign_msg(signing_key, {'type': 'create', 'nonce': secrets.token_hex(16)})

def add_op(signing_key, added_key, preds):
    """Returns an operation signed by ``signing_key``, which adds ``added_key`` to the group.
    ``preds`` is a list of hashes of immediate predecessor operations."""
    return sign_msg(signing_key, {'type': 'add', 'added_key': added_key, 'preds': preds})

def remove_op(signing_key, removed_key, preds):
    """Returns an operation signed by ``signing_key``, which removes ``removed_key`` from the group.
    ``preds`` is a list of hashes of immediate predecessor operations."""
    return sign_msg(signing_key, {'type': 'remove', 'removed_key': removed_key, 'preds': preds})

def message_op(signing_key, receptor_key, message, preds):
    """Returns an operation signed by ``signing_key``, which send ``receptor_key`` a message ``message``
    ``preds`` is a list of hashes of immediate predecessor operations."""
    return sign_msg(signing_key, {'type': 'message', 'receptor_key': receptor_key, 'message': message, 'preds': preds})

def transitive_succs(successors, hash):
    """
    Takes ``successors``, a dictionary from operation hashes to sets of successor hashes, and a
    ``hash`` to start from. Returns a set of all hashes that are reachable from that starting point.
    """
    result = {hash}
    for succ in successors.get(hash, []):
        result.update(transitive_succs(successors, succ))
    return result

def op_is_valid(hash, ops_by_hash):
    """
    Takes the hash of a node operation and sees if the actor of the operation was valid
    """

    current_op = ops_by_hash.get(hash)

    if current_op['type'] in {'add', 'remove', 'message'}:


    #DO A TOPOLOGICAL SORT

        pass


def interpret_ops(ops):
    """
    Takes a set of access control operations and computes the currently authorised set of users.
    Throws an exception if something isn't right.
    """

    # Check all the signatures and parse all the JSON
    ops_by_hash = {hex_hash(op): verify_msg(op) for op in ops}
    parsed_ops = ops_by_hash.values()


    # Every op must be one of the expected types
    if any(op['type'] not in PERMITTED_OPERATORS for op in parsed_ops):
        raise Exception('Every op must be either create, add, remove or message')
    if any('added_key' not in op for op in parsed_ops if op['type'] == 'add'):
        raise Exception('Every add operation must have an added_key')
    if any('removed_key' not in op for op in parsed_ops if op['type'] == 'remove'):
        raise Exception('Every remove operation must have a removed_key')
    if any('receptor_key' not in op or 'message' not in op for op in parsed_ops if op['type'] == 'message'):
        raise Exception('Every message operation must have a receptor_key and a message')
    

    # Hash graph integrity: every op except the initial creation must reference at least one
    # predecessor operation, and all predecessors must exist in the set
    if any(len(op['preds']) == 0 for op in parsed_ops if op['type'] != 'create'):
        raise Exception('Every non-create op must have at least one predecessor')
    if any(pred not in ops_by_hash
           for op in parsed_ops if op['type'] != 'create'
           for pred in op['preds']):
        raise Exception('Every hash must resolve to another op in the set')

    # Get the set of successor hashes for each op
    successors = {}
    for hash, op in ops_by_hash.items():
        for pred in op.get('preds', []):
            successors[pred] = successors.get(pred, set()) | {hash}

    # Get the public key of the group creator
    create_ops = [(hash, op) for hash, op in ops_by_hash.items() if op['type'] == 'create']
    if len(create_ops) != 1:
        raise Exception('There must be exactly one create operation')
    create_hash, create_op = create_ops[0]

    # Only the group creator may sign add/remove ops (TODO: change this!)
    if any(op['signed_by'] != create_op['signed_by'] for op in parsed_ops):
        raise Exception('Only the group creator may sign add/remove operations')

    # Current group members are those who have been added, and not removed again by a remove
    # operation that is a transitive successor to the add operation.
    members = set()
    for hash, op in ops_by_hash.items():
        if op['type'] in {'create', 'add'}:
            added_key = op['signed_by'] if op['type'] == 'create' else op['added_key']
            succs = [ops_by_hash[succ] for succ in transitive_succs(successors, hash)]
            if not any(succ['type'] == 'remove' and succ['removed_key'] == added_key
                       for succ in succs):
                members.add(added_key)

    for hash, op in ops_by_hash.items():
        #Check if op is valid
        op_is_valid(hash, ops_by_hash)
        
    
    return members


class TestAccessControlList(unittest.TestCase):
    # Generate keys for all the participants
    private = {name: SigningKey.generate() for name in {'alice', 'bob', 'carol', 'dave'}}
    public = {name: key.verify_key.encode().hex() for name, key in private.items()} #name: public key
    friendly_name = {public_key: name for name, public_key in public.items()} # public key: name

    def test_add_remove(self):
        # Make some example ops
        create = create_op(self.private['alice'])
        add_b = add_op(self.private['alice'], self.public['bob'], [hex_hash(create)])
        add_c = add_op(self.private['alice'], self.public['carol'], [hex_hash(create)])
        rem_b = remove_op(self.private['alice'], self.public['bob'], [hex_hash(add_b), hex_hash(add_c)])

        # Compute group membership
        members = interpret_ops({create, add_b, add_c, rem_b})
        self.assertEqual({self.friendly_name[member] for member in members}, {'alice', 'carol'})

    def test_message_1(self):
        # Make some example ops
        create = create_op(self.private['alice'])
        add_b = add_op(self.private['alice'], self.public['bob'], [hex_hash(create)])
        add_c = add_op(self.private['alice'], self.public['carol'], [hex_hash(create)])
        message_1 = message_op(self.private['alice'], self.public['carol'], "hello", [hex_hash(add_b)])

        # Compute group membership and messages
        members = interpret_ops({create, add_b, add_c, message_1})
        self

    def test_bad_signature(self):
        create = create_op(self.private['alice'])
        add_b = add_op(self.private['alice'], self.public['bob'], [hex_hash(create)])
        add_c = add_op(self.private['bob'], self.public['carol'], [hex_hash(create)])

        # A removes B with a false signature
        rem_b = remove_op(SigningKey.generate(), self.public['bob'], [hex_hash(add_b), hex_hash(add_c)])

        with self.assertRaises(Exception):
            interpret_ops({create, add_b, add_c, rem_b})
            # This should raise an exception

    def test_bad_hash(self):
        create = create_op(self.private['alice'])
        add_b = add_op(self.private['alice'], self.public['bob'], [hex_hash(create)])
        add_c = add_op(self.private['alice'], self.public['carol'], [hex_hash(create)])

        # A removes B with a false hash
        rem_b = remove_op(self.private['alice'], self.public['bob'], [hex_hash(add_b), hex_hash(add_c) + '00'])

        with self.assertRaises(Exception):
            interpret_ops({create, add_b, add_c, rem_b})
            # This should raise an exception

if __name__ == '__main__':
    unittest.main()