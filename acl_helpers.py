import json
from hashlib import sha256
from nacl.signing import VerifyKey


def hex_hash(byte_str):
    """Returns the SHA-256 hash of byte string ``byte_str``, encoded as hexadecimal."""
    return sha256(byte_str).hexdigest()


def sign_msg(signing_key, message):
    """
    Takes a message ``message`` (given as a dictionary), JSON-encodes it, and signs it using
    ``signing_key``. Returns a byte string in which the first 32 bytes are the public key, the next
    64 bytes are the signature, and the rest is the JSON-encoded message.
    """
    public_key = signing_key.verify_key.encode()
    signed_msg = signing_key.sign(json.dumps(message).encode("utf-8"))
    return public_key + signed_msg


def verify_msg(signed_msg):
    """
    Takes a byte string of the form generated by ``sign_msg()``, checks the validity of the
    signature, and parses the JSON into a dictionary. The public key that signed the message is
    added to the dictionary under the key ``signed_by`` (as a hexadecimal string). Raises an
    exception if the signature is not valid.
    """
    public_key = VerifyKey(signed_msg[0:32])  # first 32 bytes are pubkey
    verified = json.loads(public_key.verify(signed_msg[32:]))
    return {**verified, "signed_by": signed_msg[0:32].hex()}


def transitive_succs(successors, hash):
    """
    Takes ``successors``, a dictionary from operation hashes to sets of successor hashes, and a
    ``hash`` to start from. Returns a set of all hashes that are reachable from that starting point.
    """
    result = {hash}
    for succ in successors.get(hash, []):
        result.update(transitive_succs(successors, succ))
    return result
